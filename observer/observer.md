#### 观察者模式

在观察者设计模式中，对象（主题）维护了一个依赖（观察者）列表，以便主题可以使用观察者定义的任何方法通知所有观察者它所发生的变化

#### 主要目标

* 定义了对象之间一对多的依赖关系，从而使得一个对象中的任何更改都将自动通知给其他依赖对象
* 封装了主题的核心组件

#### 应用场景

* 在分布式系统汇总实现事件服务
* 用作新闻机构的框架
* 股票市场也是观察者模式的一个大型场景

#### 角色

* 主题：类subject需要了解observer，它具有许多方法，例如register（注册）等，observer可以通过这些方法注册到subject类中，因此，一个subject可以处理多个observer
* 观察者（observer）：它为关注主题的对象定义了一个接口，它定义了observer需要实现的各个方法，以便在主题发证变化时能够获取相应的通知
* 具体观察者：用来保存应该与subject的状态一致的状态，它实现了observer接口以保持其状态与主题中的变化相一致

#### 观察者模式的通知方式

推模型：观察者扮演积极的角色

* 当发生变化时，主题酒会向所有已注册的观察者进行广播
* 出现变化时，观察者负责获取相应的变化情况，或者从订户那里拉取数据
* 拉模型的效率较低，因为它设计两个步骤，第一步，主题通知观察者；第二步，观察者从主题那里提取所需的数据。

推模型：主题起主导作用的一方

* 与拉模型不同，变化由主题推送到观察者的。
* 在拉模型中，主题可以向观察者发送详细的信息（即使可能不需要）。当主题发送大量观察者用不到的数据时，会使响应时间过长
* 由于只从主题发送所需的数据，所以能够提高性能

#### 观察者模式的优缺点

优点

* 它使得彼此交互的对象之间保持松耦合
* 它使得我们可以在无需对主题或观察者进行任何修改的情况下高效地发送数据到其他对象
* 可以随时添加/删除观察者

缺点

* 观察者接口必须由具体观察者实现，而这涉及继承。无法进行组合，因为观察者接口可以实例化
* 如果实现不当的话，观察者可能会增加复杂性，并导致性能降低
* 在软件应用程序中，通知有时可能是不可靠的，并导致竞争条件或不一致